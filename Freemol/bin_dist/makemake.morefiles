#! /usr/bin/perl
#
# Usage: makemake 
#
# LIBRARIES VERSION (generate makefile for libraries).
# Generate a Makefile from the sources in the current directory. 
# To run makemake, it may be necessary to modify the first line
# of this script to point to the actual location of Perl
# on your system.
#
# The program create a file (Makefile.here) and require
# the presence of two extra files: Makelocal, Makeflags.
# The default position of these files is respectively:
# ./Makelocal
# ../Makeflags
# See anyway the configurable section. Actuallythe to files
# are expected to be there but are not required to run this
# script.
#
# Scripts for FREEMOL by F.Mariotti <fabio.mariotti@unifr.ch>
#                                   <fabio.mariotti@scriptsforscience.org>
#
# Original:
#  Written by Michael Wester <wester@math.unm.edu> February 16, 1995
#  Cotopaxi (Consulting), Albuquerque, New Mexico
#
# Version: Freemol.2000.12.01:2.1.0
#
# History:
#
# - 10 Dec 2000: Fabio Mariotti Cleanup
# - 03 Aug 2000: Fabio Mariotti Cleanup
# - 03 Nov 1999: Fabio Mariotti first version for Freemol
# - 16 Feb 1995: Michael Wester Original version
#
########################################################################
# Start Script
########################################################################
#
########################################################################
# Some Configurable Options
########################################################################
#
$filemake = "Makefile.here";
$localmake = "./Makelocal";
$flagsmake = "../Makeflags";
#
########################################################################
#
open(MAKEFILE, "> $filemake");
#
# Print Head
#
# We write the Freemol Note and the include
# lines for Makelocal and Makeflags.
#
print MAKEFILE "#\n";
print MAKEFILE "# Makefile generated by makemake for FREEMOL\n";
print MAKEFILE "#\n";
print MAKEFILE "include $flagsmake\n";
print MAKEFILE "include $localmake\n#\n";
#
# Print Main files options
#
# We want to compile for a program...??...
# Write the reference to the program name.
#
print MAKEFILE "#\n";
print MAKEFILE "# Main files\n";
print MAKEFILE "#\n";
print MAKEFILE "PROG = \$(HEREPROG)\n";
#
# Select fortran 90 source files
#
# The variable SRCS in the makefile
# will contain all the file names of
# fortran files present in the current directory.
#
print MAKEFILE "SRCS = ";
@srcsf = <*.f90 *.F90>;
&PrintWords(8, 0, @srcsf);
print MAKEFILE "\n";
#
# Detect object files
#
# We do the same for the object files (OBJS)
#
print MAKEFILE "OBJS = ";
@objsf = @srcsf;
foreach (@objsf) { s/\.[^.]+$/.o/ };
&PrintWords(8, 0, @objsf);
print MAKEFILE "\n";
#
# Print Libraries
#
# We print a reference to used libraries:
# We need to names: one for general libraries from Makeflags
# and one for local libraries from Makelocal.
#
print MAKEFILE "LIBS = \$(USEDLIBS)\n";
print MAKEFILE "LLIB = \$(HERELIBS)\n";
#
# Print Other source files if any
#
# Other sources? include them all in the same variable: OSRCS
#
print MAKEFILE "OSRCS = ";
@srcs = <*.f77 *.f *.F *.c>;
&PrintWords(8, 0, @srcs);
print MAKEFILE "\n";
#
# Select Other Object files
#
# Same for objects (OOBJS)
#
print MAKEFILE "OOBJS = ";
@objs = @srcs;
foreach (@objs) { s/\.[^.]+$/.o/ };
&PrintWords(8, 0, @objs);
print MAKEFILE "\n";
#
# Print field for any other library
#
# For coerence: Other Libraries: (OLIBS)
#
print MAKEFILE "OLIBS = \n";
print MAKEFILE "#\n";
print MAKEFILE "#\n";
#
# make all target: local libraries and documents
#
# The main target for the makefile is all
# and will point to local
#
print MAKEFILE "#\n";
print MAKEFILE "# Main Targets\n";
print MAKEFILE "#\n";
print MAKEFILE "   all: \$(LLIB) docs\n\n";
print MAKEFILE ".PHONY: all docs\n\n";
#
# make objects
#
print MAKEFILE "#\n";
print MAKEFILE "# Make Objects\n";
print MAKEFILE "#\n";
foreach $lsrcsf (@srcsf) {
    $lobjsf = $lsrcsf;
    $lobjsf =~ s/\.[^.]+$/.o/;
    print MAKEFILE "   $lobjsf : $lsrcsf\n";
    print MAKEFILE "\t\$(FC) \$(FFLAGS) \$(SECFLAGS) -c \$< -o \$\@\n\n";
    print MAKEFILE "\n";
};
#
# make local library
#
print MAKEFILE "\$(LLIB): \$(OBJS)\n";
print MAKEFILE "\t\$(AR) \$(ARFLAGS) \$(LLIB) \$(OBJS)\n";
print MAKEFILE "\tcp \$(LLIB) \$(FMLIBDIR)/.\n";
#
# We suppose the compiler to store the modules
# in the correct directory. Otherwise
# uncomment this line
#
# print MAKEFILE "\tcp -f *.mod \$(FMMODDIR)/.\n\n";
#
# make documents
#
print MAKEFILE "#\n";
print MAKEFILE "# Create Documents\n";
print MAKEFILE "#\n";
print MAKEFILE "   fundoc.txt:\$(SRCS)\n";
print MAKEFILE "\tcat \$(SRCS) | grep \"^!H\" | sed \"s/^!H/  /\" > fundoc.txt\n\n";
print MAKEFILE "   docs:fundoc.txt\n";
print MAKEFILE "\tcp fundoc.txt \$(FMDOCDIR)/\$(LLIB).txt\n\n";
#
# make clean target
#
print MAKEFILE "clean:\n";
print MAKEFILE "\trm -f \$(PROG) \$(OBJS) \$(LLIB) *.mod\n\n";
#
# Make .f90 a valid suffix
#
print MAKEFILE ".SUFFIXES: \$(SUFFIXES) .f90 .F90\n\n";
#
# Extra infos
# .f90 -> .o
#
# print MAKEFILE ".f90.o:\n";
# print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c \$<\n\n";
#
# Dependency listings
#
print MAKEFILE "#\n";
print MAKEFILE "# DEPENDENCIES\n";
print MAKEFILE "#\n";
#
# We use the Freemol subfunction
# the others are available as well!
#
&MakeDependsFREEMOL($ARGV[1]);
#
#&MakeDependsf90($ARGV[1]);
#&MakeDepends("*.f *.F", '^\s*include\s+["\']([^"\']+)["\']');
#&MakeDepends("*.c",     '^\s*#\s*include\s+["\']([^"\']+)["\']');
#
#
# &PrintWords(current output column, extra tab?, word list); --- print words
#    nicely
#
sub PrintWords {
    local($columns) = 78 - shift(@_);
    local($extratab) = shift(@_);
    local($wordlength);
    #
    print MAKEFILE @_[0];
    $columns -= length(shift(@_));
    foreach $word (@_) {
	$wordlength = length($word);
	if ($wordlength + 1 < $columns) {
	    print MAKEFILE " $word";
	    $columns -= $wordlength + 1;
	}
	else {
	    #
	    # Continue onto a new line
	    #
	    if ($extratab) {
		print MAKEFILE " \\\n\t\t$word";
		$columns = 62 - $wordlength;
            }
	    else {
		print MAKEFILE " \\\n\t$word";
		$columns = 70 - $wordlength;
            }
	}
    }
}

#
# &toLower(string); --- convert string into lower case
#
sub toLower {
    local($string) = @_[0];
    $string =~ tr/A-Z/a-z/;
    $string;
}

#
# &uniq(sorted word list); --- remove adjacent duplicate words
#
sub uniq {
    local(@words);
    foreach $word (@_) {
	if ($word ne $words[$#words]) {
         push(@words, $word);
     }
    }
    @words;
}

#
# &MakeDepends(language pattern, include file sed pattern); --- dependency
#    maker
#
sub MakeDepends {
    local(@incs);
    local($lang) = @_[0];
    local($pattern) = @_[1];
    #
    foreach $file (<${lang}>) {
        open(FILE, $file) || warn "Cannot open $file: $!\n";
	while (<FILE>) {
	    /$pattern/i && push(@incs, $1);
	}
	if (defined @incs) {
	    $file =~ s/\.[^.]+$/.o/;
	    print MAKEFILE "$file: ";
	    &PrintWords(length($file) + 2, 0, @incs);
	    print MAKEFILE "\n";
	    undef @incs;
	}
    }
}

#
# &MakeDependsf90(f90 compiler); --- FORTRAN 90 dependency maker
#
sub MakeDependsf90 {
    local($compiler) = &toLower(@_[0]);
    local(@dependencies);
    local(%filename);
    local(@incs);
    local(@modules);
    local($objfile);
    #
    # Associate each module with the name of the file that contains it
    #
    foreach $file (<*.f90>) {
	open(FILE, $file) || warn "Cannot open $file: $!\n";
	while (<FILE>) {
	    /^\s*module\s+([^\s!]+)/i &&
		($filename{&toLower($1)} = $file) =~ s/\.f90$/.o/;
	}
    }
    #
    # Print the dependencies of each file that has one or more include's or
    # references one or more modules
    #
    foreach $file (<*.f90>) {
	open(FILE, $file);
	while (<FILE>) {
	    /^\s*include\s+["\']([^"\']+)["\']/i && push(@incs, $1);
            /^\s*use\s+([^\s,!]+)/i && push(@modules, &toLower($1));
        }
	if (defined @incs || defined @modules) {
	    ($objfile = $file) =~ s/\.f90$/.o/;
	    print MAKEFILE "$objfile: ";
	    undef @dependencies;
	    foreach $module (@modules) {
		push(@dependencies, $filename{$module});
            }
	    @dependencies = &uniq(sort(@dependencies));
	    &PrintWords(length($objfile) + 2, 0,
			@dependencies, &uniq(sort(@incs)));
	    print MAKEFILE "\n";
	    undef @incs;
	    undef @modules;
	    #
	    # Cray F90 compiler
	    #
	    if ($compiler eq "cray") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    push(@modules, "-p", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
	    }
	    #
	    # ParaSoft F90 compiler
	    #
	    if ($compiler eq "parasoft") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    $depend =~ s/\.o$/.f90/;
		    push(@modules, "-module", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
	    }
	}
    }
}
#
# &MakeDependsFREEMOL(f90 compiler); --- FORTRAN 90 dependency maker for FREEMOL
#
# Same as MakeDependsf90 but search in freemol directories for dependencies and
# search modules definition in .f90 files while use statment in .F90 file
#
sub MakeDependsFREEMOL {
    local($compiler) = &toLower(@_[0]);
    local(@dependencies);
    local(%filename);
    local(@incs);
    local(@modules);
    local($objfile);
    #
    # Associate each module with the name of the file that contains it
    #
    foreach $file (<*.f90>) {
	open(FILE, $file) || warn "Cannot open $file: $!\n";
	while (<FILE>) {
	    /^\s*module\s+([^\s!]+)/i &&
		($filename{&toLower($1)} = $file) =~ s/\.f90$/.o/;
	}
    }
    foreach $file (<*.F90>) {
	open(FILE, $file) || warn "Cannot open $file: $!\n";
	while (<FILE>) {
	    /^\s*module\s+([^\s!]+)/i &&
		($filename{&toLower($1)} = $file) =~ s/\.F90$/.o/;
	}
    }
    #
    # Print the dependencies of each file that has one or more include's or
    # references one or more modules
    #
    foreach $file (<*.f90>) {
	open(FILE, $file);
	while (<FILE>) {
            /^\s*include\s+["\']([^"\']+)["\']/i && push(@incs, $1);
            /^\s*use\s+([^\s,!]+)/i && push(@modules, &toLower($1));
        }
        if (defined @incs || defined @modules) {
	    ($objfile = $file) =~ s/\.f90$/.o/;
	    print MAKEFILE "$objfile: ";
	    undef @dependencies;
	    foreach $module (@modules) {
		push(@dependencies, $filename{$module});
            }
	    @dependencies = &uniq(sort(@dependencies));
	    &PrintWords(length($objfile) + 2, 0,
			@dependencies, &uniq(sort(@incs)));
	    print MAKEFILE "\n";
	    undef @incs;
	    undef @modules;
	    #
	    # Cray F90 compiler
	    #
	    if ($compiler eq "cray") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    push(@modules, "-p", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
            }
	    #
	    # ParaSoft F90 compiler
	    #
	    if ($compiler eq "parasoft") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    $depend =~ s/\.o$/.f90/;
		    push(@modules, "-module", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
            }
	}
    }
    foreach $file (<*.F90>) {
	open(FILE, $file);
	while (<FILE>) {
            /^\s*include\s+["\']([^"\']+)["\']/i && push(@incs, $1);
            /^\s*use\s+([^\s,!]+)/i && push(@modules, &toLower($1));
        }
        if (defined @incs || defined @modules) {
	    ($objfile = $file) =~ s/\.F90$/.o/;
	    print MAKEFILE "$objfile: ";
	    undef @dependencies;
	    foreach $module (@modules) {
		push(@dependencies, $filename{$module});
            }
	    @dependencies = &uniq(sort(@dependencies));
	    &PrintWords(length($objfile) + 2, 0,
			@dependencies, &uniq(sort(@incs)));
	    print MAKEFILE "\n";
	    undef @incs;
	    undef @modules;
	    #
	    # Cray F90 compiler
	    #
	    if ($compiler eq "cray") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    push(@modules, "-p", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
            }
	    #
	    # ParaSoft F90 compiler
	    #
	    if ($compiler eq "parasoft") {
		print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
		foreach $depend (@dependencies) {
		    $depend =~ s/\.o$/.F90/;
		    push(@modules, "-module", $depend);
		}
		push(@modules, $file);
		&PrintWords(30, 1, @modules);
		print MAKEFILE "\n";
		undef @modules;
            }
	}
    }
}
